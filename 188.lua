-- Migrated from 188_CF_CBG_2_01_4.vxml
-- Replaced/missing prompts (generated):
--  CF_CBG_2_0320.wav, CF_CBG_2_0321.wav, CF_CBG_2_03214.wav,
--  CF_CBG_2_0322.wav, CF_CBG_2_0179.wav,
--  errorhandling0002.wav, errorhandling0003.wav, errorhandling0005.wav, errorhandling0006.wav
-- These were generated by gTTS and placed under /usr/share/freeswitch/sounds/custom

-- Use the global 'session' provided by mod_lua when the script is run from the dialplan.
-- Guard and exit cleanly when no session is present.
if not session then
    if rawget(_G, "freeswitch") and freeswitch.consoleLog then
      freeswitch.consoleLog("ERR", "migrate_188: no session available; must be executed from dialplan via mod_lua\n")
    end
    return
  end
  
  -- Utility to play a prompt and optionally collect DTMF
  local function play_and_collect(s, prompt_path, max_digits, timeout_ms)
    -- Play prompt and optionally collect DTMF during playback.
    -- Use playAndGetDigits when we expect digits so the prompt is played once and
    -- digits pressed during playback are captured. If no collection is needed
    -- streamFile is used.
    if max_digits and tonumber(max_digits) and tonumber(max_digits) > 0 then
      local digits = s:playAndGetDigits(1, tonumber(max_digits), 1, timeout_ms or 5000, "", prompt_path, "", "")
      return digits
    else
      s:streamFile(prompt_path)
      return nil
    end
  end
  
  -- Simple helper to test whether a file exists on disk and log if missing.
  local function file_exists(path)
    local f = io.open(path, "rb")
    if f then f:close(); return true end
    if rawget(_G, "freeswitch") and freeswitch.consoleLog then
      freeswitch.consoleLog("WARN", "migrate_188: missing prompt file: " .. tostring(path) .. "\n")
    end
    return false
  end
  
  -- Config: how many retries VXML allows before taking the exceed action
  local MAX_RETRIES = 3
  
  -- Simple menu history logger (replacement for VXML INSERT_MENU_HISTORY subdialog).
  -- Writes a CSV-like line with timestamp, call uuid (if available), menu id, event, details.
  local function insert_menu_history(s, menu_id, event, details)
    local uuid = "unknown"
    if s and s.getVariable then
      uuid = s:getVariable("uuid") or s:getVariable("call_uuid") or uuid
    end
    local ts = os.date("%Y-%m-%d %H:%M:%S")
    local ln = string.format('%s,%s,%s,%s,%s\n', ts, tostring(uuid), tostring(menu_id), tostring(event), tostring(details or ""))
    local path = "/var/log/freeswitch/migrate_menu_history.log"
    local f, err = io.open(path, "a")
    if not f then
      if rawget(_G, "freeswitch") and freeswitch.consoleLog then
        freeswitch.consoleLog("ERR", "migrate_188: unable to open history log: " .. tostring(err) .. "\n")
      end
      return false
    end
    f:write(ln)
    f:close()
    return true
  end
  
  
  -- Map prompts to full paths
  local SOUNDS_DIR = "/usr/share/freeswitch/sounds/custom"
  
  -- Chinese prompts (generated earlier)
  local PROMPTS_CN = {
    main_menu = SOUNDS_DIR .. "/CF_CBG_2_0320.wav",
    content_desc = SOUNDS_DIR .. "/CF_CBG_2_0321.wav",
    option_prompt = SOUNDS_DIR .. "/CF_CBG_2_03214.wav",
    next_step = SOUNDS_DIR .. "/CF_CBG_2_0322.wav",
    more_options = SOUNDS_DIR .. "/CF_CBG_2_0179.wav",
    err_no_input = SOUNDS_DIR .. "/errorhandling0002.wav",
    err_invalid = SOUNDS_DIR .. "/errorhandling0003.wav",
    err_too_many_noinput = SOUNDS_DIR .. "/errorhandling0005.wav",
    err_too_many_invalid = SOUNDS_DIR .. "/errorhandling0006.wav",
  }
  
  -- English prompts (newly generated, suffix _en)
  local PROMPTS_EN = {
    main_menu = SOUNDS_DIR .. "/CF_CBG_2_0320_en.wav",
    content_desc = SOUNDS_DIR .. "/CF_CBG_2_0321_en.wav",
    option_prompt = SOUNDS_DIR .. "/CF_CBG_2_03214_en.wav",
    next_step = SOUNDS_DIR .. "/CF_CBG_2_0322_en.wav",
    more_options = SOUNDS_DIR .. "/CF_CBG_2_0179_en.wav",
    err_no_input = SOUNDS_DIR .. "/errorhandling0002_en.wav",
    err_invalid = SOUNDS_DIR .. "/errorhandling0003_en.wav",
    err_too_many_noinput = SOUNDS_DIR .. "/errorhandling0005_en.wav",
    err_too_many_invalid = SOUNDS_DIR .. "/errorhandling0006_en.wav",
  }
  
  -- Add language selection prompts into both tables (same files used for prompting language)
  -- Use the single combined bilingual prompt (CN then EN) for language selection.
  PROMPTS_CN.language_select = SOUNDS_DIR .. "/language_selection_both.wav"
  PROMPTS_EN.language_select = PROMPTS_CN.language_select
  
  -- Ask the user using the combined prompt; capture presses during playback.
  local lang = nil
  for attempt = 1, 3 do
    local sel = nil
    if file_exists(PROMPTS_CN.language_select) then
      sel = session:playAndGetDigits(1, 1, 1, 5000, "", PROMPTS_CN.language_select, "", "")
    else
      -- If the combined prompt is missing, fall back to playing CN then EN sequentially
      if file_exists(SOUNDS_DIR .. "/language_selection_cn.wav") then
        session:streamFile(SOUNDS_DIR .. "/language_selection_cn.wav")
      end
      if file_exists(SOUNDS_DIR .. "/language_selection_en.wav") then
        session:streamFile(SOUNDS_DIR .. "/language_selection_en.wav")
      end
      -- After fallback playback allow a short window to capture digits
      sel = session:getDigits(1, "", 5000)
    end
    if sel == "1" then
      lang = "cn"
      break
    elseif sel == "2" then
      lang = "en"
      break
    end
    -- else retry
  end
  -- if still not chosen, fall back to channel variable or default to Chinese
  if not lang then
    lang = session:getVariable("language") or session:getVariable("lang") or "cn"
  end
  local PROMPTS = (string.lower(lang) == "en") and PROMPTS_EN or PROMPTS_CN
  
  -- Main call flow
  local function main(s)
    if not s:ready() then return end
  
    -- Play main menu and collect 1 digit
    -- Centralized retry counters (align with VXML behavior)
    local noinput_count = 0
    local nomatch_count = 0
    local choice = nil
  
    -- Log menu entry
    insert_menu_history(s, "MENU_01", "ENTRY", "start")
  
    for attempt = 1, MAX_RETRIES do
      s:consoleLog("info", "[migrate] Playing main menu prompt (attempt " .. attempt .. "): " .. PROMPTS.main_menu .. "\n")
      insert_menu_history(s, "MENU_01", "ATTEMPT", attempt)
      choice = play_and_collect(s, PROMPTS.main_menu, 1, 5000)
  
      if not choice or choice == "" then
        noinput_count = noinput_count + 1
        s:consoleLog("info", string.format("[migrate] noinput_count=%d nomatch_count=%d", noinput_count, nomatch_count) .. "\n")
        if noinput_count >= MAX_RETRIES then
          s:streamFile(PROMPTS.err_too_many_noinput)
          insert_menu_history(s, "MENU_01", "EXCEED_NOINPUT", string.format("noinput=%d", noinput_count))
          s:hangup()
          return
        else
          s:streamFile(PROMPTS.err_no_input)
          -- retry loop continues
        end
  
      else
        -- we received something; validate
        if choice == "1" or choice == "2" or choice == "3" then
          break -- valid choice; exit retry loop
        else
          nomatch_count = nomatch_count + 1
          s:consoleLog("info", string.format("[migrate] nomatch_count=%d", nomatch_count) .. "\n")
          if nomatch_count >= MAX_RETRIES then
            s:streamFile(PROMPTS.err_too_many_invalid)
            insert_menu_history(s, "MENU_01", "EXCEED_NOMATCH", string.format("nomatch=%d", nomatch_count))
            s:hangup()
            return
          else
            s:streamFile(PROMPTS.err_invalid)
            -- retry loop continues
          end
        end
      end
    end
  
    -- Log final selection (if any)
    insert_menu_history(s, "MENU_01", "SELECTION", choice or "")
  
    -- Handle choices (example mapping inferred from VXML)
    if choice == "1" then
      -- Sales flow
      s:consoleLog("info", "[migrate] User selected Sales (1)\n")
      s:streamFile(PROMPTS.content_desc)
      -- Continue with additional prompts/transfer as required
    elseif choice == "2" then
      -- Customer service
      s:consoleLog("info", "[migrate] User selected Customer Service (2)\n")
      -- Continue to MENU_02
      if file_exists(PROMPTS.more_options) then
        -- play the announcement then go to the menu
        s:streamFile(PROMPTS.more_options)
      end
      -- call the next menu implementation
      if menu_02 then menu_02(s) end
    elseif choice == "3" then
      -- Other
      s:consoleLog("info", "[migrate] User selected Other (3)\n")
      s:streamFile(PROMPTS.option_prompt)
    else
      -- Invalid input
      s:streamFile(PROMPTS.err_invalid)
      -- allow one retry (capture early DTMF during prompt)
      choice = play_and_collect(s, PROMPTS.main_menu, 1, 5000)
      if not choice or choice == "" then
        s:streamFile(PROMPTS.err_too_many_noinput)
        s:hangup()
        return
      elseif choice ~= "1" and choice ~= "2" and choice ~= "3" then
        s:streamFile(PROMPTS.err_too_many_invalid)
        -- Transfer or hangup per original behavior; here we hangup
        s:hangup()
        return
      end
    end
  
    -- Example end
    s:consoleLog("info", "[migrate] Call flow completed / reached end of migrated logic\n")
    -- hang up if still active
    if s:ready() then s:hangup() end
  end
  
  -- Execute when invoked by FreeSWITCH
  if session and session:ready() then
    main(session)
  end
  
  -- Forward declare menu_02 so it can be called from main
  function menu_02(s)
    -- Basic MENU_02 implementation: similar retry behavior as MENU_01
    if not s:ready() then return end
    local noinput_count = 0
    local nomatch_count = 0
    local choice = nil
  
    insert_menu_history(s, "MENU_02", "ENTRY", "start")
  
    for attempt = 1, MAX_RETRIES do
      insert_menu_history(s, "MENU_02", "ATTEMPT", attempt)
      choice = play_and_collect(s, PROMPTS.main_menu, 1, 5000) -- TODO: replace with PROMPTS specific to MENU_02
      if not choice or choice == "" then
        noinput_count = noinput_count + 1
        if noinput_count >= MAX_RETRIES then
          s:streamFile(PROMPTS.err_too_many_noinput)
          insert_menu_history(s, "MENU_02", "EXCEED_NOINPUT", noinput_count)
          s:hangup()
          return
        else
          s:streamFile(PROMPTS.err_no_input)
        end
      else
        if choice == "1" or choice == "2" then
          break
        else
          nomatch_count = nomatch_count + 1
          if nomatch_count >= MAX_RETRIES then
            s:streamFile(PROMPTS.err_too_many_invalid)
            insert_menu_history(s, "MENU_02", "EXCEED_NOMATCH", nomatch_count)
            s:hangup()
            return
          else
            s:streamFile(PROMPTS.err_invalid)
          end
        end
      end
    end
  
    insert_menu_history(s, "MENU_02", "SELECTION", choice or "")
    -- TODO: implement actual MENU_02 handlers/branches from VXML
  end
  